package com.kh.chap02_abstract.part02.model.vo;

//컴파일 완료후 최종결과는 .class로 동일하다
public interface Basic { 
	/* public static final */ int num = 10;
	//초기화하지 않으면 에러발생 => final 변수라서 
	//변수명이 기울여져있다 => static 변수임을 의미
	
	/*
	 * 인터페이스 내부에서는 상수필드(public static final)만 정의 가능
	 * 따라서, 상수필드예약어를 생략해도 항상 자동으로 추가되어 있다
	 */
	
	//일반적인 메서드 선언이 불가능하다
	/*
	 * 인터페이스 내부에서는 추상메서드만 정의할 수 있다
	 * 기본 메서드는 항상 추상메서드로 간주하기 때문에 public abstract 생략가능
	 */
	/* public abstract */ void eat();
	
	/*
	 * 인터페이스
	 *   - 상수필드와 추상메서드만 사용 가능한 추상클래스의 번형체(jdk7 이전)
	 *   - 8버전 이후부터는 default?????
	 *   - 인터페이스에서 필드는 무조건 "상수필드"이며, 메서드는 무조건 "추상메서드"
	 *   - 특정클래스에서 무조건 구현해야하는 기능이 존재하는 경우 인터페이스를 만들어 상속
	 *   
	 * why 인터페이스?
	 *   - 자바는 100프로 단일상속만 지원하기 때문에 추상클래스만으로는 한계가 있음
	 *   - 하지만 인터페이스는 다중상속(다중구현)을 허용한다
	 *   - 인터페이스들은 결국 메서드의 이름, 반환형, 매개변수만 정의하고 있으므로
	 *     최종 구현 부분은 인터페이스를 상속받은 클래스에서 딱 한번만 이루어지므로
	 *     다중상속이 가능하다
	 *   - 추상클래스와 다르게 강한 규칙성으로 통일된 인터페이스를 갖추게 할 때 사용
	 *   
	 * 추상클래스와 인터페이스
	 * 1. 공통점
	 *   - 객체 생성은 안되나, 참조변수로서 사용 가능(상속개념이라 업캐스팅이 가능하기 때문)
	 *   - 인터페이스 및 추상클래스를 상속받는 클래스에서는 추상메서드를 강제로 구현해야 한다.
	 * 2. 차이점
	 *   - 추상클래스에서는 인스턴스 변수(필드) 및 일반 메서드를 생성할 수 있지만,
	 *     인터페이스는 오직 상수필드와 추상 메서드만 사용 가능하다.
	 *   - 사용하는 목적이 다르다
	 *   	i) 추상클래스는 클래스들이 가지는 공통 속성과 기능을 자식클래스에게 상속시키면서
	 *   	   특정 기능 구현을 강제하고자 할 때 사용하기 때문에 "상속"이 주 목적이고,
	 *   	   "강제기능구현"은 부가적인 목적이다.
	 *   	ii) 인터페이스는 클래스의 기능 구현을 "약속"하기 위해 사용한다. 인터페이스를 구현한
	 *   		모든 클래스는 "동일한 동작"을 보장할 수 있다. 일관된 동작을 보장하기 위해 사용한다.
	 *   		(추상클래스의 추상메서드 부분과 유사하다)
	 *   
	 * 인터페이스의 상속(implements)
	 *   - 클래스와 클래스의 상속 관계 : 클래스명 extends 부모클래스
	 *   - 클래스와 인터페이스의 상속(구현) 관계 : 클래스명 implements 인터페이스명[, 인터페이스, 인터페이스]
	 *   - 인터페이스와 인터페이스의 상속 관계 : 인터페이스명 extends 인터페이스명[, 인터페이스, 인터페이스]
	 *     (인터페이스는 인터페이스 끼리의 상속만 가능하다, 인터페이스는 다중상속이 가능하다)
	 */
	
	//JDK8버전 이후
	//인터페이스 내부에서 디폴트 메서드를 사용할 수 있다
	//인터페이스를 구현하는 모든 하위 클래스에서 공통된 기능이 존재하는 경우 사용
	default void breathing() {
		System.out.println("숨쉬기");
	}
	//차이:구현한 클래스가 객체생성 후에 실행시킬 수 있도록 만든 메서드
	
	//정적메서드는 사용가능
	//상수필드를 사용할 수 있는 이유와 같다
	//객체를 생성 안해도 접근할 수 있기 떄문에
	//마찬가지로 정적메서드도 객체생성이 불필요한 메서드이기 때문에 사용가능
	static void thinking() {
		System.out.println("생각하기");
	}
	//차이:스태틱한 방법으로 불러야 실행됨
	/*
	 * 상수필드와 동일하게 "객체생성 없이" 접근가능한 메서드이므로 인터페이스에서도 작성할 수 있다.
	 */
}
